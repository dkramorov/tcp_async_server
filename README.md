# tcp_async_server
Сервис для обмена сообщениями с платой

Получаем сообщения от платы, записываем,
отдаем ответ

Инструкция для разработчика по разворачиванию проекта:

```
git clone https://github.com/dkramorov/tcp_async_server.git
python3.6 -m venv env
source env/bin/activate
pip install -r requirements.txt
./tcp_async_server.py
```

# Запуск через супервизор
```
apt-get install supervisor
cd /etc/supervisor/conf.d
touch tcp_server.conf

# Конфигурация супервизора
[program:tcp_server]
directory=/home/jocker/sites/
command=/home/jocker/sites/env/bin/python3 tcp_async_server.py
stderr_logfile=/var/log/tcp_server.log
stdout_logfile=/var/log/tcp_server.log
autostart=true
autorestart=true
```

# структура сообщения от устройства
- ACon_V1.0 		//заголовок
- ID=1953			//ID устройства (у каждого свой)
- SEND=141349		//номер сообщения (при перезагрузке счётчик обнуляется)
- CONNECTION=1		//соединение, по к-рому передаётся текущий пакет: 1 - Wi, 2 - GSM
- WIFI_STATE=0		//состояние подключения по Wi-Fi
- GSM_STATE=0		//состояние подключения по GSM
- //1 - аппаратная ошибка, 2 - нет точки доступа (wi), 3 - нет интернета, 0 - всё есть
- RESET=1			//1 - произошла перезагрузка устройства, иначе - 0
STATE=0
- //состояние: 0 - норма, 1 - короткое замыкание, 2 - неправильно набран код 3 раза подряд, 3 - заблокирован сервером (доступ запрещён)
- //если несколько - через запятую (список может дополняться)
- COLS=8			//количество столбцов
- ROWS=8			//количество строк
- ACT_CON=01011011,11111111,10110111,11111111,10011111,11111111,10110111,11111111
- //подключённые к плате замки (самодиагностика): 8 строк по 8 ячеек (макс.), 1 - замок подключён, 0 - не подключён
- BOX_ENG=2,5,8,23,24,25	//номера ячеек, для которых есть пароль и не истекло время, 0 - таких нет
- BOX_TO=33,34		//номера ячеек, для которых истекло время, 0 - таких нет
- BOX_ACC=1,54,43		//номера ячеек, к которым был осуществлён доступ, 0 - таких нет
- CLOSE			//конец сообщения

# структура сообщения от сервера (ответ)
- ACon_V1.0 		//заголовок
- ID=1953			//ID платы
- SEND=141349		//номер сообщения (такой же, как в запросе)
- RESET=0			//0 - ничего не делать, 1 - перезагрузить устройство
- STATE=0			//0 - ничего не делать, 3 - заблокировать доступ
- BOX_ENG=(2,1492,4800)	//номер ячейки, пароль (шифрование?), время в минутах
- BOX_ENG=(5,1492,4800)	//этот список передаётся в каждом ответе от сервера,
- BOX_ENG=(8,1492,4800)	//устройство полностью обновляет свои данные каждый раз
- BOX_ENG=(23,1492,4800)
- BOX_ENG=(24,1492,4800)
- BOX_ENG=(25,1492,4800)
- CLOSE			//конец сообщения

# Пояснение по номеру сообщения.
Получив запрос, сервер формирует ответ. Если устройство не получает ответ по истечении какого-то времени, оно снова инициирует запрос с номером на единицу больше. Если номер в ответе не соответствует номеру в запросе, то устройство делает вывод, что это ответ на старый запрос, который по какой-то причине поздно пришёл, и игнорирует этот ответ, т.к. он может содержать устаревшую информацию.

Пояснение по параметрам COLS и ROWS:
Ячейки расположены в виртуальном пространстве в виде прямоугольной матрицы, нумерация идёт вправо затем вниз. COLS - количество столбцов этой матрицы, ROWS - количество строк. Параметры влияют только на нумерацию. Нужно это для того, чтобы виртуальная нумерация соответствовала физической, т.к. в реальности ячейки не обязательно должны располагаться квадратом 8х8, может быть и 5х6. Количество столбцов и строк знает устройство и передаёт в каждом сообщении.

Пояснение по доступу к ячейкам.
Ячейка, с точки зрения устройства, может находиться в двух состояниях - занята и неактивна. Занята - это когда ей назначен код и время действия, в этом случае её можно открыть, набрав код. Неактивна - это когда её нельзя открыть, набрав код. В обоих случаях устройство не знает, пуста ячейка или в ней что-то находится, и с какой целью набирается код - что-то положить или что-то взять.
